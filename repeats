#!/usr/bin/env python
"""
Prints paths of identical files to stdout, separated by tab (\t).

How it works
------------
The script calculates the MD5 checksums of all the files of the same size
underneath the base path I use as my argument. If these MD5s match, the path
is printed.

How to use it
-------------
### List identical pictures in my album.
    $ ./repeats ~/album
        ~/album/_import/IMG_0034.JPG	~/album/my-trip/IMG_0034.JPG
"""
import functools
import hashlib
import os
import os.path
import sys
from collections import defaultdict


DELIMINATOR = "\t"


def main(where):
    for line in repeats(where):
        print(line)


def repeats(where):
    limiters = [by_size, by_md5]
    all_files = list(get_all_files(where))
    groups = [all_files]
    groups = by_size(groups)
    groups = by_md5(groups)
    matches = groups
    for same_list in matches:
        yield(DELIMINATOR.join(same_list))


def get_all_files(where):
    filerecords = os.walk(where)
    for dirpath, dirnames, filenames in filerecords:
        for name in filenames:
            yield os.path.join(dirpath, name)


def get_limiters():
    return {
        'by_size': os.path.getsize,
        'by_md5': calculate_md5,
    }


def apply_limiter(groups_of_possible_matches, limiter):
    results = []
    for possible_match in groups_of_possible_matches:
        keyfunc = get_limiters()[limiter]
        new_elements = group_by(possible_match, keyfunc).values()
        for element in new_elements:
            if len(element) > 1:
                results.append(element)
    return results


_by_size = functools.partial(apply_limiter, limiter='by_size')
def by_size(candidates):
    return _by_size(candidates)


_by_md5 = functools.partial(apply_limiter, limiter='by_md5')
def by_md5(candidates):
    p = Pool(5)
    return _by_md5(candidates)


def calculate_md5(path):
    """
    Returns the MD5 hash for a file at ``path``.
    """
    md5 = hashlib.md5()
    with open(path) as openfile:
        while True:
            buf = openfile.read(128)
            if not buf:
                break
            md5.update(buf)
    return md5.hexdigest()


def group_by(iterable, keyfunc):
    groups = defaultdict(list)
    for iterated in iterable:
        result = keyfunc(iterated)
        groups[result].append(iterated)
    return groups


if __name__ == "__main__":
    try:
        where = sys.argv[1]
    except IndexError:
        where = "./"
    main(where)
